
# to repeat the important information

Notes: currently partial specialization SFINAE is not formally supported by the standard (see also CWG issue 2054), however, LFTS requires it works since version 2 (see also detection idiom).

-- LFTS stands for Library Fundamentals Technical Specification
-- see https://cplusplus.github.io/fundamentals-ts/



SFINAE in partial specializations

Deduction and substitution also occur while determining whether a specialization of a class or variable (since C++14) template is generated by some partial specialization or the primary template. Compilers do not treat a substitution failure as a hard-error during such determination, but ignore the corresponding partial specialization declaration instead, as if in the overload resolution involving function templates.

// primary template handles non-referenceable types:
template<class T, class = void>
struct reference_traits
{
    using add_lref = T;
    using add_rref = T;
};

// specialization recognizes referenceable types:
template<class T>
struct reference_traits<T, std::void_t<T&>>
{
    using add_lref = T&;
    using add_rref = T&&;
};

template<class T>
using add_lvalue_reference_t = typename reference_traits<T>::add_lref;

template<class T>
using add_rvalue_reference_t = typename reference_traits<T>::add_rref;



Notes: currently partial specialization SFINAE is not formally supported by the standard (see also CWG issue 2054), however, LFTS requires it works since version 2 (see also detection idiom).


Library support

The standard library component std::enable_if allows for creating a substitution failure in order to enable or disable particular overloads based on a condition evaluated at compile time.

In addition, many type traits must be implemented with SFINAE if appropriate compiler extensions are unavailable.


(since C++11)

The standard library component std::void_t is another utility metafunction that simplifies partial specialization SFINAE applications.


(since C++17)


Alternatives

Where applicable, tag dispatch, if constexpr (since C++17), and concepts (since C++20) are usually preferred over use of SFINAE.

static_assert is usually preferred over SFINAE if only a conditional compile time error is wanted.

(since C++11)



How does `void_t` work

https://stackoverflow.com/questions/27687389/how-does-void-t-work


SFINAE and partial class template specializations

https://stackoverflow.com/questions/30676839/sfinae-and-partial-class-template-specializations
